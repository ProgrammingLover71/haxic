<?php
/**
 * Generated by Haxe 4.3.7
 */

namespace src;

use \php\_Boot\HxAnon;
use \src\ast\ForeachStmt;
use \src\ast\StringExpr;
use \src\ast\NumberExpr;
use \src\ast\BooleanExpr;
use \src\ast\VariableExpr;
use \php\Boot;
use \haxe\Exception;
use \src\ast\BinaryExpr;
use \src\ast\IfStmt;
use \src\ast\LetStmt;
use \src\ast\NullExpr;
use \haxe\Log;
use \src\ast\PrintStmt;
use \src\ast\FunctionStmt;
use \src\ast\CallExpr;
use \src\ast\IndexExpr;
use \src\ast\UnaryExpr;
use \src\ast\InputStmt;
use \src\ast\ArrayExpr;
use \src\ast\ReturnStmt;
use \src\ast\Expr;
use \src\ast\Stmt;
use \src\ast\Parameter;
use \src\ast\BlockStmt;
use \src\ast\WhileStmt;
use \src\ast\ExprStmt;

class Parser {
	/**
	 * @var int
	 */
	public $position;
	/**
	 * @var ScopeState[]|\Array_hx
	 */
	public $scopeStates;
	/**
	 * @var Token[]|\Array_hx
	 */
	public $tokens;

	/**
	 * @param Token[]|\Array_hx $tokens
	 * 
	 * @return void
	 */
	public function __construct ($tokens) {
		#src/Parser.hx:15: characters 31-32
		$this->position = 0;
		#src/Parser.hx:20: characters 9-29
		$this->tokens = $tokens;
		#src/Parser.hx:21: characters 9-42
		$this->scopeStates = \Array_hx::wrap([ScopeState::Global()]);
	}

	/**
	 * @return Token
	 */
	public function advance () {
		#src/Parser.hx:356: characters 9-35
		if (!$this->isAtEnd()) {
			#src/Parser.hx:356: characters 25-35
			$this->position++;
		}
		#src/Parser.hx:357: characters 9-26
		return $this->previous();
	}

	/**
	 * @return Expr
	 */
	public function call () {
		#src/Parser.hx:273: characters 9-29
		$expr = $this->factor();
		#src/Parser.hx:274: lines 274-291
		while (true) {
			#src/Parser.hx:275: lines 275-290
			if ($this->match(TokenType::LPAREN())) {
				#src/Parser.hx:276: characters 17-43
				$args = new \Array_hx();
				#src/Parser.hx:277: lines 277-281
				if (!$this->check(TokenType::RPAREN())) {
					#src/Parser.hx:278: lines 278-280
					do {
						#src/Parser.hx:279: characters 25-48
						$x = $this->comparison();
						$args->arr[$args->length++] = $x;
					} while ($this->match(TokenType::COMMA()));
				}
				#src/Parser.hx:282: characters 17-88
				$paren = $this->consume(TokenType::RPAREN(), "Expected ')' after arguments.");
				#src/Parser.hx:283: characters 17-74
				$expr = new CallExpr($expr, $args, $paren->line, $paren->column);
			} else if ($this->match(TokenType::LBRACK())) {
				#src/Parser.hx:285: characters 17-46
				$indexExpr = $this->comparison();
				#src/Parser.hx:286: characters 17-91
				$rbrack = $this->consume(TokenType::RBRACK(), "Expected ']' after array index.");
				#src/Parser.hx:287: characters 17-82
				$expr = new IndexExpr($expr, $indexExpr, $rbrack->line, $rbrack->column);
			} else {
				#src/Parser.hx:289: characters 17-22
				break;
			}
		}
		#src/Parser.hx:292: characters 9-20
		return $expr;
	}

	/**
	 * @param TokenType $type
	 * 
	 * @return bool
	 */
	public function check ($type) {
		#src/Parser.hx:350: characters 9-36
		if ($this->isAtEnd()) {
			#src/Parser.hx:350: characters 24-36
			return false;
		}
		#src/Parser.hx:351: characters 9-35
		return $this->peek()->type === $type;
	}

	/**
	 * @return Expr
	 */
	public function comparison () {
		#src/Parser.hx:230: characters 9-32
		$left = $this->expr();
		#src/Parser.hx:231: lines 231-235
		while ($this->match(TokenType::GT()) || $this->match(TokenType::GTEQ()) || $this->match(TokenType::LT()) || $this->match(TokenType::LTEQ()) || $this->match(TokenType::EQEQ()) || $this->match(TokenType::NOTEQ())) {
			#src/Parser.hx:232: characters 13-41
			$oper = $this->previous();
			#src/Parser.hx:233: characters 13-37
			$right = $this->term();
			#src/Parser.hx:234: characters 13-77
			$left = new BinaryExpr($left, $oper, $right, $oper->line, $oper->column);
		}
		#src/Parser.hx:236: characters 9-20
		return $left;
	}

	/**
	 * @param TokenType $type
	 * @param string $message
	 * 
	 * @return Token
	 */
	public function consume ($type, $message) {
		#src/Parser.hx:344: characters 9-42
		if ($this->check($type)) {
			#src/Parser.hx:344: characters 26-42
			return $this->advance();
		}
		#src/Parser.hx:345: characters 9-14
		throw Exception::thrown(($message??'null') . " -- Found: " . \Std::string($this->peek()));
	}

	/**
	 * @return Expr
	 */
	public function expr () {
		#src/Parser.hx:241: characters 9-32
		$left = $this->term();
		#src/Parser.hx:242: lines 242-246
		while ($this->match(TokenType::PLUS()) || $this->match(TokenType::MINUS())) {
			#src/Parser.hx:243: characters 13-41
			$oper = $this->previous();
			#src/Parser.hx:244: characters 13-37
			$right = $this->term();
			#src/Parser.hx:245: characters 13-77
			$left = new BinaryExpr($left, $oper, $right, $oper->line, $oper->column);
		}
		#src/Parser.hx:247: characters 9-20
		return $left;
	}

	/**
	 * @return Expr
	 */
	public function factor () {
		#src/Parser.hx:297: lines 297-299
		if ($this->match(TokenType::NUMBER())) {
			#src/Parser.hx:298: characters 35-67
			$tmp = \Std::parseFloat($this->previous()->value);
			#src/Parser.hx:298: characters 69-84
			$tmp1 = $this->previous()->line;
			#src/Parser.hx:298: characters 13-104
			return new NumberExpr($tmp, $tmp1, $this->previous()->column);
		}
		#src/Parser.hx:300: lines 300-304
		if ($this->match(TokenType::LPAREN())) {
			#src/Parser.hx:301: characters 13-31
			$expr = $this->expr();
			#src/Parser.hx:302: characters 13-72
			$this->consume(TokenType::RPAREN(), "Expected ')' after expression.");
			#src/Parser.hx:303: characters 13-24
			return $expr;
		}
		#src/Parser.hx:305: lines 305-307
		if ($this->match(TokenType::IDENTIFIER())) {
			#src/Parser.hx:306: characters 37-53
			$tmp = $this->previous()->value;
			#src/Parser.hx:306: characters 55-70
			$tmp1 = $this->previous()->line;
			#src/Parser.hx:306: characters 13-90
			return new VariableExpr($tmp, $tmp1, $this->previous()->column);
		}
		#src/Parser.hx:308: lines 308-310
		if ($this->match(TokenType::STRING())) {
			#src/Parser.hx:309: characters 35-51
			$tmp = $this->previous()->value;
			#src/Parser.hx:309: characters 53-68
			$tmp1 = $this->previous()->line;
			#src/Parser.hx:309: characters 13-88
			return new StringExpr($tmp, $tmp1, $this->previous()->column);
		}
		#src/Parser.hx:311: lines 311-314
		if ($this->check(TokenType::KEYWORD()) && (($this->peek()->value === "true") || ($this->peek()->value === "false"))) {
			#src/Parser.hx:312: characters 13-32
			$kw = $this->advance();
			#src/Parser.hx:313: characters 13-75
			return new BooleanExpr($kw->value === "true", $kw->line, $kw->column);
		}
		#src/Parser.hx:315: lines 315-318
		if ($this->check(TokenType::KEYWORD()) && ($this->peek()->value === "null")) {
			#src/Parser.hx:316: characters 13-32
			$kw = $this->advance();
			#src/Parser.hx:317: characters 13-52
			return new NullExpr($kw->line, $kw->column);
		}
		#src/Parser.hx:319: lines 319-329
		if ($this->check(TokenType::LBRACK())) {
			#src/Parser.hx:320: characters 13-22
			$this->advance();
			#src/Parser.hx:321: characters 13-43
			$elements = new \Array_hx();
			#src/Parser.hx:322: lines 322-326
			if (!$this->check(TokenType::RBRACK())) {
				#src/Parser.hx:323: lines 323-325
				do {
					#src/Parser.hx:324: characters 21-48
					$x = $this->comparison();
					$elements->arr[$elements->length++] = $x;
				} while ($this->match(TokenType::COMMA()));
			}
			#src/Parser.hx:327: characters 13-76
			$this->consume(TokenType::RBRACK(), "Expected ']' after array elements.");
			#src/Parser.hx:328: characters 44-59
			$tmp = $this->previous()->line;
			#src/Parser.hx:328: characters 13-79
			return new ArrayExpr($elements, $tmp, $this->previous()->column);
		}
		#src/Parser.hx:330: characters 9-14
		throw Exception::thrown("Unexpected token in factor: " . \Std::string($this->peek()));
	}

	/**
	 * @return bool
	 */
	public function isAtEnd () {
		#src/Parser.hx:362: characters 9-41
		return $this->position >= $this->tokens->length;
	}

	/**
	 * @param TokenType $type
	 * 
	 * @return bool
	 */
	public function match ($type) {
		#src/Parser.hx:335: lines 335-338
		if ($this->check($type)) {
			#src/Parser.hx:336: characters 13-22
			$this->advance();
			#src/Parser.hx:337: characters 13-24
			return true;
		}
		#src/Parser.hx:339: characters 9-21
		return false;
	}

	/**
	 * @return Stmt[]|\Array_hx
	 */
	public function parse () {
		#src/Parser.hx:26: characters 9-41
		$statements = new \Array_hx();
		#src/Parser.hx:27: lines 27-29
		while (!$this->isAtEnd()) {
			#src/Parser.hx:28: characters 13-46
			$x = $this->parseStatement();
			$statements->arr[$statements->length++] = $x;
		}
		#src/Parser.hx:30: characters 9-26
		return $statements;
	}

	/**
	 * @param string[]|\Array_hx $terminators
	 * @param int $line
	 * @param int $column
	 * 
	 * @return BlockStmt
	 */
	public function parseBlockWithTerminators ($terminators, $line, $column) {
		#src/Parser.hx:204: characters 9-41
		$statements = new \Array_hx();
		#src/Parser.hx:205: lines 205-207
		while (!$this->isAtEnd() && !($this->check(TokenType::KEYWORD()) && ($terminators->indexOf($this->peek()->value) !== -1))) {
			#src/Parser.hx:206: characters 13-46
			$x = $this->parseStatement();
			$statements->arr[$statements->length++] = $x;
		}
		#src/Parser.hx:209: characters 9-55
		return new BlockStmt($statements, $line, $column);
	}

	/**
	 * @return LetStmt
	 */
	public function parseDecStatement () {
		#src/Parser.hx:139: characters 9-18
		$this->advance();
		#src/Parser.hx:140: characters 9-84
		$name = $this->consume(TokenType::IDENTIFIER(), "Expected variable after 'dec'.");
		#src/Parser.hx:141: characters 9-69
		$this->consume(TokenType::SEMICOLON(), "Expected ';' after variable.");
		#src/Parser.hx:142: characters 9-76
		$varExpr = new VariableExpr($name->value, $name->line, $name->column);
		#src/Parser.hx:143: characters 9-61
		$one = new NumberExpr(1, $name->line, $name->column);
		#src/Parser.hx:144: characters 9-132
		$binary = new BinaryExpr($varExpr, new Token(TokenType::MINUS(), "-", $name->line, $name->column), $one, $name->line, $name->column);
		#src/Parser.hx:145: characters 46-68
		$tmp = ($name->value === null ? "null" : \Std::string($name->value));
		#src/Parser.hx:145: characters 9-127
		return new LetStmt(\Array_hx::wrap([new VariableExpr($tmp, $name->line, $name->column)]), $binary, $name->line, $name->column);
	}

	/**
	 * @return ForeachStmt
	 */
	public function parseForeachStatement () {
		#src/Parser.hx:89: characters 9-18
		$this->advance();
		#src/Parser.hx:90: characters 9-89
		$name = $this->consume(TokenType::IDENTIFIER(), "Expected loop variable after 'for'.");
		#src/Parser.hx:91: characters 9-73
		$this->consume(TokenType::KEYWORD(), "Expected 'in' after loop variable.");
		#src/Parser.hx:92: characters 9-44
		if ($this->previous()->value !== "in") {
			#src/Parser.hx:92: characters 39-44
			throw Exception::thrown("Expected 'in' after loop variable.");
		}
		#src/Parser.hx:93: characters 9-37
		$iterable = $this->comparison();
		#src/Parser.hx:94: characters 9-68
		$this->consume(TokenType::KEYWORD(), "Expected 'do' after iterable.");
		#src/Parser.hx:95: characters 9-44
		if ($this->previous()->value !== "do") {
			#src/Parser.hx:95: characters 39-44
			throw Exception::thrown("Expected 'do' after iterable.");
		}
		#src/Parser.hx:96: characters 9-42
		$_this = $this->scopeStates;
		$_this->arr[$_this->length++] = ScopeState::Loop();
		#src/Parser.hx:98: characters 9-91
		$body = $this->parseBlockWithTerminators(\Array_hx::wrap(["end"]), $this->previous()->line, $this->previous()->column);
		#src/Parser.hx:99: characters 9-87
		$kwEnd = $this->consume(TokenType::KEYWORD(), "Expected 'end' after for statement.");
		#src/Parser.hx:100: characters 9-40
		if ($kwEnd->value !== "end") {
			#src/Parser.hx:100: characters 35-40
			throw Exception::thrown("Expected 'end' after for statement.");
		}
		#src/Parser.hx:102: characters 9-26
		$_this = $this->scopeStates;
		if ($_this->length > 0) {
			$_this->length--;
		}
		\array_pop($_this->arr);
		#src/Parser.hx:104: characters 9-125
		return new ForeachStmt(new VariableExpr($name->value, $name->line, $name->column), $iterable, $body, $name->line, $name->column);
	}

	/**
	 * @return FunctionStmt
	 */
	public function parseFunctionStatement () {
		#src/Parser.hx:165: characters 9-18
		$this->advance();
		#src/Parser.hx:166: characters 9-95
		$nameToken = $this->consume(TokenType::IDENTIFIER(), "Expected function name after 'func'.");
		#src/Parser.hx:167: characters 9-36
		$name = $nameToken->value;
		#src/Parser.hx:168: characters 9-71
		$this->consume(TokenType::LPAREN(), "Expected '(' after function name.");
		#src/Parser.hx:169: characters 9-57
		$params = $this->parseParameters();
		#src/Parser.hx:170: characters 9-68
		$this->consume(TokenType::RPAREN(), "Expected ')' after parameters.");
		#src/Parser.hx:172: characters 9-46
		$_this = $this->scopeStates;
		$_this->arr[$_this->length++] = ScopeState::Function();
		#src/Parser.hx:173: characters 9-91
		$body = $this->parseBlockWithTerminators(\Array_hx::wrap(["end"]), $this->previous()->line, $this->previous()->column);
		#src/Parser.hx:174: characters 9-87
		$kwEnd = $this->consume(TokenType::KEYWORD(), "Expected 'end' after function body.");
		#src/Parser.hx:175: characters 9-40
		if ($kwEnd->value !== "end") {
			#src/Parser.hx:175: characters 35-40
			throw Exception::thrown("Expected 'end' after function body.");
		}
		#src/Parser.hx:177: characters 9-26
		$_this = $this->scopeStates;
		if ($_this->length > 0) {
			$_this->length--;
		}
		\array_pop($_this->arr);
		#src/Parser.hx:178: characters 9-14
		(Log::$trace)($params, new HxAnon([
			"fileName" => "src/Parser.hx",
			"lineNumber" => 178,
			"className" => "src.Parser",
			"methodName" => "parseFunctionStatement",
		]));
		#src/Parser.hx:179: characters 9-86
		return new FunctionStmt($name, $params, $body, $nameToken->line, $nameToken->column);
	}

	/**
	 * @return IfStmt
	 */
	public function parseIfStatement () {
		#src/Parser.hx:109: characters 9-18
		$this->advance();
		#src/Parser.hx:110: characters 9-38
		$condition = $this->comparison();
		#src/Parser.hx:111: characters 9-71
		$this->consume(TokenType::KEYWORD(), "Expected 'then' after condition.");
		#src/Parser.hx:112: characters 9-46
		if ($this->previous()->value !== "then") {
			#src/Parser.hx:112: characters 41-46
			throw Exception::thrown("Expected 'then' after condition.");
		}
		#src/Parser.hx:113: characters 9-105
		$thenBranch = $this->parseBlockWithTerminators(\Array_hx::wrap([
			"else",
			"end",
		]), $this->previous()->line, $this->previous()->column);
		#src/Parser.hx:114: characters 9-41
		$elseBranch = null;
		#src/Parser.hx:115: lines 115-118
		if ($this->check(TokenType::KEYWORD()) && ($this->peek()->value === "else")) {
			#src/Parser.hx:116: characters 13-22
			$this->advance();
			#src/Parser.hx:117: characters 13-96
			$elseBranch = $this->parseBlockWithTerminators(\Array_hx::wrap(["end"]), $this->previous()->line, $this->previous()->column);
		}
		#src/Parser.hx:120: characters 9-86
		$kwEnd = $this->consume(TokenType::KEYWORD(), "Expected 'end' after if statement.");
		#src/Parser.hx:121: characters 9-40
		if ($kwEnd->value !== "end") {
			#src/Parser.hx:121: characters 35-40
			throw Exception::thrown("Expected 'end' after if statement.");
		}
		#src/Parser.hx:123: characters 9-95
		return new IfStmt($condition, $thenBranch, $elseBranch, $condition->line, $condition->column);
	}

	/**
	 * @return LetStmt
	 */
	public function parseIncStatement () {
		#src/Parser.hx:128: characters 9-18
		$this->advance();
		#src/Parser.hx:129: characters 9-84
		$name = $this->consume(TokenType::IDENTIFIER(), "Expected variable after 'inc'.");
		#src/Parser.hx:130: characters 9-69
		$this->consume(TokenType::SEMICOLON(), "Expected ';' after variable.");
		#src/Parser.hx:131: characters 9-76
		$varExpr = new VariableExpr($name->value, $name->line, $name->column);
		#src/Parser.hx:132: characters 9-61
		$one = new NumberExpr(1, $name->line, $name->column);
		#src/Parser.hx:133: characters 9-131
		$binary = new BinaryExpr($varExpr, new Token(TokenType::PLUS(), "+", $name->line, $name->column), $one, $name->line, $name->column);
		#src/Parser.hx:134: characters 46-68
		$tmp = ($name->value === null ? "null" : \Std::string($name->value));
		#src/Parser.hx:134: characters 9-127
		return new LetStmt(\Array_hx::wrap([new VariableExpr($tmp, $name->line, $name->column)]), $binary, $name->line, $name->column);
	}

	/**
	 * @return InputStmt
	 */
	public function parseInputStatement () {
		#src/Parser.hx:44: characters 9-18
		$this->advance();
		#src/Parser.hx:45: characters 9-86
		$name = $this->consume(TokenType::IDENTIFIER(), "Expected variable after 'input'.");
		#src/Parser.hx:46: characters 9-66
		$this->consume(TokenType::SEMICOLON(), "Expected ';' after value.");
		#src/Parser.hx:47: characters 9-107
		return new InputStmt(new VariableExpr($name->value, $name->line, $name->column), $name->line, $name->column);
	}

	/**
	 * @return LetStmt
	 */
	public function parseLetStatement () {
		#src/Parser.hx:52: characters 9-18
		$this->advance();
		#src/Parser.hx:53: characters 9-47
		$bindings = new \Array_hx();
		#src/Parser.hx:54: lines 54-57
		do {
			#src/Parser.hx:55: characters 13-98
			$name = $this->consume(TokenType::IDENTIFIER(), "Expected variable name in let statement.");
			#src/Parser.hx:56: characters 13-80
			$x = new VariableExpr($name->value, $name->line, $name->column);
			$bindings->arr[$bindings->length++] = $x;
		} while ($this->match(TokenType::COMMA()));
		#src/Parser.hx:59: lines 59-67
		if ($this->check(TokenType::EQUALS())) {
			#src/Parser.hx:60: characters 13-93
			$this->consume(TokenType::EQUALS(), "Expected '=' after variable names in let statement.");
			#src/Parser.hx:61: characters 13-38
			$value = $this->comparison();
			#src/Parser.hx:62: characters 13-70
			$this->consume(TokenType::SEMICOLON(), "Expected ';' after value.");
			#src/Parser.hx:63: characters 49-64
			$tmp = $this->previous()->line;
			#src/Parser.hx:63: characters 13-84
			return new LetStmt($bindings, $value, $tmp, $this->previous()->column);
		} else {
			#src/Parser.hx:65: characters 13-79
			$this->consume(TokenType::SEMICOLON(), "Expected ';' after variable names.");
			#src/Parser.hx:66: characters 48-63
			$tmp = $this->previous()->line;
			#src/Parser.hx:66: characters 13-83
			return new LetStmt($bindings, null, $tmp, $this->previous()->column);
		}
	}

	/**
	 * @return Parameter[]|\Array_hx
	 */
	public function parseParameters () {
		#src/Parser.hx:184: characters 9-42
		$params = new \Array_hx();
		#src/Parser.hx:186: lines 186-197
		if (!$this->check(TokenType::RPAREN())) {
			#src/Parser.hx:187: lines 187-196
			do {
				#src/Parser.hx:188: characters 17-86
				$name = $this->consume(TokenType::IDENTIFIER(), "Expected parameter name.");
				#src/Parser.hx:189: characters 17-46
				$defaultValue = null;
				#src/Parser.hx:191: lines 191-193
				if ($this->match(TokenType::EQUALS())) {
					#src/Parser.hx:192: characters 21-42
					$defaultValue = $this->expr();
				}
				#src/Parser.hx:195: characters 17-93
				$x = new Parameter($name->value, $defaultValue, $name->line, $name->column);
				$params->arr[$params->length++] = $x;
			} while ($this->match(TokenType::COMMA()));
		}
		#src/Parser.hx:199: characters 9-22
		return $params;
	}

	/**
	 * @return PrintStmt
	 */
	public function parsePrintStatement () {
		#src/Parser.hx:36: characters 9-18
		$this->advance();
		#src/Parser.hx:37: characters 9-33
		$expr = $this->comparison();
		#src/Parser.hx:38: characters 9-66
		$this->consume(TokenType::SEMICOLON(), "Expected ';' after value.");
		#src/Parser.hx:39: characters 36-51
		$tmp = $this->previous()->line;
		#src/Parser.hx:39: characters 9-71
		return new PrintStmt($expr, $tmp, $this->previous()->column);
	}

	/**
	 * @return ReturnStmt
	 */
	public function parseReturnStatement () {
		#src/Parser.hx:150: lines 150-160
		if (($this->scopeStates->arr[$this->scopeStates->length - 1] ?? null) === ScopeState::Function()) {
			#src/Parser.hx:151: characters 13-22
			$this->advance();
			#src/Parser.hx:152: characters 42-57
			$expr = $this->previous()->line;
			#src/Parser.hx:152: characters 13-78
			$expr1 = new NullExpr($expr, $this->previous()->column);
			#src/Parser.hx:153: lines 153-155
			if (!$this->check(TokenType::SEMICOLON())) {
				#src/Parser.hx:154: characters 17-36
				$expr1 = $this->comparison();
			}
			#src/Parser.hx:156: characters 13-58
			$this->consume(TokenType::SEMICOLON(), "Expected ';'.");
			#src/Parser.hx:157: characters 41-56
			$tmp = $this->previous()->line;
			#src/Parser.hx:157: characters 13-76
			return new ReturnStmt($expr1, $tmp, $this->previous()->column);
		} else {
			#src/Parser.hx:159: characters 13-18
			throw Exception::thrown("Return statement not allowed outside of function at line " . ($this->peek()->line??'null') . ", column " . ($this->peek()->column??'null'));
		}
	}

	/**
	 * @return Stmt
	 */
	public function parseStatement () {
		#src/Parser.hx:214: characters 9-94
		if ($this->check(TokenType::KEYWORD()) && ($this->peek()->value === "print")) {
			#src/Parser.hx:214: characters 66-94
			return $this->parsePrintStatement();
		}
		#src/Parser.hx:215: characters 9-94
		if ($this->check(TokenType::KEYWORD()) && ($this->peek()->value === "input")) {
			#src/Parser.hx:215: characters 66-94
			return $this->parseInputStatement();
		}
		#src/Parser.hx:216: characters 9-90
		if ($this->check(TokenType::KEYWORD()) && ($this->peek()->value === "let")) {
			#src/Parser.hx:216: characters 64-90
			return $this->parseLetStatement();
		}
		#src/Parser.hx:217: characters 9-88
		if ($this->check(TokenType::KEYWORD()) && ($this->peek()->value === "if")) {
			#src/Parser.hx:217: characters 63-88
			return $this->parseIfStatement();
		}
		#src/Parser.hx:218: characters 9-94
		if ($this->check(TokenType::KEYWORD()) && ($this->peek()->value === "while")) {
			#src/Parser.hx:218: characters 66-94
			return $this->parseWhileStatement();
		}
		#src/Parser.hx:219: characters 9-94
		if ($this->check(TokenType::KEYWORD()) && ($this->peek()->value === "for")) {
			#src/Parser.hx:219: characters 64-94
			return $this->parseForeachStatement();
		}
		#src/Parser.hx:220: characters 9-90
		if ($this->check(TokenType::KEYWORD()) && ($this->peek()->value === "inc")) {
			#src/Parser.hx:220: characters 64-90
			return $this->parseIncStatement();
		}
		#src/Parser.hx:221: characters 9-90
		if ($this->check(TokenType::KEYWORD()) && ($this->peek()->value === "dec")) {
			#src/Parser.hx:221: characters 64-90
			return $this->parseDecStatement();
		}
		#src/Parser.hx:222: characters 9-96
		if ($this->check(TokenType::KEYWORD()) && ($this->peek()->value === "return")) {
			#src/Parser.hx:222: characters 67-96
			return $this->parseReturnStatement();
		}
		#src/Parser.hx:223: characters 9-96
		if ($this->check(TokenType::KEYWORD()) && ($this->peek()->value === "func")) {
			#src/Parser.hx:223: characters 65-96
			return $this->parseFunctionStatement();
		}
		#src/Parser.hx:226: characters 29-41
		$tmp = $this->comparison();
		#src/Parser.hx:226: characters 43-54
		$tmp1 = $this->peek()->line;
		#src/Parser.hx:226: characters 9-70
		return new ExprStmt($tmp, $tmp1, $this->peek()->column);
	}

	/**
	 * @return WhileStmt
	 */
	public function parseWhileStatement () {
		#src/Parser.hx:72: characters 9-18
		$this->advance();
		#src/Parser.hx:73: characters 9-38
		$condition = $this->comparison();
		#src/Parser.hx:74: characters 9-69
		$this->consume(TokenType::KEYWORD(), "Expected 'do' after condition.");
		#src/Parser.hx:75: characters 9-44
		if ($this->previous()->value !== "do") {
			#src/Parser.hx:75: characters 39-44
			throw Exception::thrown("Expected 'do' after condition.");
		}
		#src/Parser.hx:76: characters 9-42
		$_this = $this->scopeStates;
		$_this->arr[$_this->length++] = ScopeState::Loop();
		#src/Parser.hx:78: characters 9-91
		$body = $this->parseBlockWithTerminators(\Array_hx::wrap(["end"]), $this->previous()->line, $this->previous()->column);
		#src/Parser.hx:79: characters 9-89
		$kwEnd = $this->consume(TokenType::KEYWORD(), "Expected 'end' after while statement.");
		#src/Parser.hx:80: characters 9-40
		if ($kwEnd->value !== "end") {
			#src/Parser.hx:80: characters 35-40
			throw Exception::thrown("Expected 'end' after while statement.");
		}
		#src/Parser.hx:82: characters 9-26
		$_this = $this->scopeStates;
		if ($_this->length > 0) {
			$_this->length--;
		}
		\array_pop($_this->arr);
		#src/Parser.hx:84: characters 9-80
		return new WhileStmt($condition, $body, $condition->line, $condition->column);
	}

	/**
	 * @return Token
	 */
	public function peek () {
		#src/Parser.hx:367: characters 16-51
		if ($this->isAtEnd()) {
			#src/Parser.hx:367: characters 28-32
			return null;
		} else {
			#src/Parser.hx:367: characters 35-51
			return ($this->tokens->arr[$this->position] ?? null);
		}
	}

	/**
	 * @return Token
	 */
	public function previous () {
		#src/Parser.hx:372: characters 16-58
		if ($this->position > 0) {
			#src/Parser.hx:372: characters 31-51
			return ($this->tokens->arr[$this->position - 1] ?? null);
		} else {
			#src/Parser.hx:372: characters 54-58
			return null;
		}
	}

	/**
	 * @return Expr
	 */
	public function term () {
		#src/Parser.hx:252: characters 9-33
		$left = $this->unary();
		#src/Parser.hx:253: lines 253-257
		while ($this->match(TokenType::STAR()) || $this->match(TokenType::SLASH())) {
			#src/Parser.hx:254: characters 13-41
			$oper = $this->previous();
			#src/Parser.hx:255: characters 13-38
			$right = $this->unary();
			#src/Parser.hx:256: characters 13-77
			$left = new BinaryExpr($left, $oper, $right, $oper->line, $oper->column);
		}
		#src/Parser.hx:258: characters 9-20
		return $left;
	}

	/**
	 * @return Expr
	 */
	public function unary () {
		#src/Parser.hx:263: lines 263-267
		if ($this->check(TokenType::BANG()) || $this->check(TokenType::MINUS())) {
			#src/Parser.hx:264: characters 13-40
			$oper = $this->advance();
			#src/Parser.hx:265: characters 13-38
			$right = $this->unary();
			#src/Parser.hx:266: characters 13-70
			return new UnaryExpr($oper, $right, $oper->line, $oper->column);
		}
		#src/Parser.hx:268: characters 9-22
		return $this->call();
	}
}

Boot::registerClass(Parser::class, 'src.Parser');
