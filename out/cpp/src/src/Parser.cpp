// Generated by Haxe 4.3.7
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_src_Parser
#include <src/Parser.h>
#endif
#ifndef INCLUDED_src_Token
#include <src/Token.h>
#endif
#ifndef INCLUDED_src_TokenType
#include <src/TokenType.h>
#endif
#ifndef INCLUDED_src_ast_BinaryExpr
#include <src/ast/BinaryExpr.h>
#endif
#ifndef INCLUDED_src_ast_BlockStmt
#include <src/ast/BlockStmt.h>
#endif
#ifndef INCLUDED_src_ast_BooleanExpr
#include <src/ast/BooleanExpr.h>
#endif
#ifndef INCLUDED_src_ast_Expr
#include <src/ast/Expr.h>
#endif
#ifndef INCLUDED_src_ast_ExprStmt
#include <src/ast/ExprStmt.h>
#endif
#ifndef INCLUDED_src_ast_IfStmt
#include <src/ast/IfStmt.h>
#endif
#ifndef INCLUDED_src_ast_InputStmt
#include <src/ast/InputStmt.h>
#endif
#ifndef INCLUDED_src_ast_LetStmt
#include <src/ast/LetStmt.h>
#endif
#ifndef INCLUDED_src_ast_Node
#include <src/ast/Node.h>
#endif
#ifndef INCLUDED_src_ast_NumberExpr
#include <src/ast/NumberExpr.h>
#endif
#ifndef INCLUDED_src_ast_PrintStmt
#include <src/ast/PrintStmt.h>
#endif
#ifndef INCLUDED_src_ast_Stmt
#include <src/ast/Stmt.h>
#endif
#ifndef INCLUDED_src_ast_StringExpr
#include <src/ast/StringExpr.h>
#endif
#ifndef INCLUDED_src_ast_UnaryExpr
#include <src/ast/UnaryExpr.h>
#endif
#ifndef INCLUDED_src_ast_VariableExpr
#include <src/ast/VariableExpr.h>
#endif
#ifndef INCLUDED_src_ast_WhileStmt
#include <src/ast/WhileStmt.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_274b98ea9fd940c5_5_new,"src.Parser","new",0x68619ebb,"src.Parser.new","src/Parser.hx",5,0x4a8448f4)
HX_LOCAL_STACK_FRAME(_hx_pos_274b98ea9fd940c5_15_parse,"src.Parser","parse",0x9f37eb4e,"src.Parser.parse","src/Parser.hx",15,0x4a8448f4)
HX_LOCAL_STACK_FRAME(_hx_pos_274b98ea9fd940c5_25_parsePrintStatement,"src.Parser","parsePrintStatement",0xd2789e30,"src.Parser.parsePrintStatement","src/Parser.hx",25,0x4a8448f4)
HX_LOCAL_STACK_FRAME(_hx_pos_274b98ea9fd940c5_33_parseInputStatement,"src.Parser","parseInputStatement",0xbb0a4eb3,"src.Parser.parseInputStatement","src/Parser.hx",33,0x4a8448f4)
HX_LOCAL_STACK_FRAME(_hx_pos_274b98ea9fd940c5_41_parseLetStatement,"src.Parser","parseLetStatement",0x69e04d42,"src.Parser.parseLetStatement","src/Parser.hx",41,0x4a8448f4)
HX_LOCAL_STACK_FRAME(_hx_pos_274b98ea9fd940c5_61_parseWhileStatement,"src.Parser","parseWhileStatement",0x2597222c,"src.Parser.parseWhileStatement","src/Parser.hx",61,0x4a8448f4)
static const ::String _hx_array_data_0a6f2549_8[] = {
	HX_("end",db,03,4d,00),
};
HX_LOCAL_STACK_FRAME(_hx_pos_274b98ea9fd940c5_74_parseIfStatement,"src.Parser","parseIfStatement",0x4f302be4,"src.Parser.parseIfStatement","src/Parser.hx",74,0x4a8448f4)
static const ::String _hx_array_data_0a6f2549_10[] = {
	HX_("else",b9,e4,14,43),HX_("end",db,03,4d,00),
};
static const ::String _hx_array_data_0a6f2549_11[] = {
	HX_("end",db,03,4d,00),
};
HX_LOCAL_STACK_FRAME(_hx_pos_274b98ea9fd940c5_93_parseIncStatement,"src.Parser","parseIncStatement",0x6781d3df,"src.Parser.parseIncStatement","src/Parser.hx",93,0x4a8448f4)
HX_LOCAL_STACK_FRAME(_hx_pos_274b98ea9fd940c5_104_parseDecStatement,"src.Parser","parseDecStatement",0x96f2ea7b,"src.Parser.parseDecStatement","src/Parser.hx",104,0x4a8448f4)
HX_LOCAL_STACK_FRAME(_hx_pos_274b98ea9fd940c5_115_parseBlockWithTerminators,"src.Parser","parseBlockWithTerminators",0x709e5e27,"src.Parser.parseBlockWithTerminators","src/Parser.hx",115,0x4a8448f4)
HX_LOCAL_STACK_FRAME(_hx_pos_274b98ea9fd940c5_125_parseStatement,"src.Parser","parseStatement",0x169db301,"src.Parser.parseStatement","src/Parser.hx",125,0x4a8448f4)
HX_LOCAL_STACK_FRAME(_hx_pos_274b98ea9fd940c5_138_comparison,"src.Parser","comparison",0x61b91e4e,"src.Parser.comparison","src/Parser.hx",138,0x4a8448f4)
HX_LOCAL_STACK_FRAME(_hx_pos_274b98ea9fd940c5_149_expr,"src.Parser","expr",0xe724be7a,"src.Parser.expr","src/Parser.hx",149,0x4a8448f4)
HX_LOCAL_STACK_FRAME(_hx_pos_274b98ea9fd940c5_160_term,"src.Parser","term",0xf10088b1,"src.Parser.term","src/Parser.hx",160,0x4a8448f4)
HX_LOCAL_STACK_FRAME(_hx_pos_274b98ea9fd940c5_171_unary,"src.Parser","unary",0x88c3b0ca,"src.Parser.unary","src/Parser.hx",171,0x4a8448f4)
HX_LOCAL_STACK_FRAME(_hx_pos_274b98ea9fd940c5_181_factor,"src.Parser","factor",0xa83af554,"src.Parser.factor","src/Parser.hx",181,0x4a8448f4)
HX_LOCAL_STACK_FRAME(_hx_pos_274b98ea9fd940c5_204_match,"src.Parser","match",0xe505a460,"src.Parser.match","src/Parser.hx",204,0x4a8448f4)
HX_LOCAL_STACK_FRAME(_hx_pos_274b98ea9fd940c5_213_consume,"src.Parser","consume",0xfc5e1197,"src.Parser.consume","src/Parser.hx",213,0x4a8448f4)
HX_LOCAL_STACK_FRAME(_hx_pos_274b98ea9fd940c5_219_check,"src.Parser","check",0x2798f3e3,"src.Parser.check","src/Parser.hx",219,0x4a8448f4)
HX_LOCAL_STACK_FRAME(_hx_pos_274b98ea9fd940c5_225_advance,"src.Parser","advance",0xd28fa05d,"src.Parser.advance","src/Parser.hx",225,0x4a8448f4)
HX_LOCAL_STACK_FRAME(_hx_pos_274b98ea9fd940c5_232_isAtEnd,"src.Parser","isAtEnd",0xa6c8fc39,"src.Parser.isAtEnd","src/Parser.hx",232,0x4a8448f4)
HX_LOCAL_STACK_FRAME(_hx_pos_274b98ea9fd940c5_237_peek,"src.Parser","peek",0xee5ba2e0,"src.Parser.peek","src/Parser.hx",237,0x4a8448f4)
HX_LOCAL_STACK_FRAME(_hx_pos_274b98ea9fd940c5_242_previous,"src.Parser","previous",0x535203fc,"src.Parser.previous","src/Parser.hx",242,0x4a8448f4)
namespace src{

void Parser_obj::__construct(::Array< ::Dynamic> tokens){
            	HX_STACKFRAME(&_hx_pos_274b98ea9fd940c5_5_new)
HXLINE(   7)		this->position = 0;
HXLINE(  11)		this->tokens = tokens;
            	}

Dynamic Parser_obj::__CreateEmpty() { return new Parser_obj; }

void *Parser_obj::_hx_vtable = 0;

Dynamic Parser_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Parser_obj > _hx_result = new Parser_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool Parser_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x4ed243e3;
}

::Array< ::Dynamic> Parser_obj::parse(){
            	HX_STACKFRAME(&_hx_pos_274b98ea9fd940c5_15_parse)
HXLINE(  16)		::Array< ::Dynamic> statements = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  17)		while(!(this->isAtEnd())){
HXLINE(  18)			statements->push(this->parseStatement());
            		}
HXLINE(  20)		return statements;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Parser_obj,parse,return )

 ::src::ast::PrintStmt Parser_obj::parsePrintStatement(){
            	HX_GC_STACKFRAME(&_hx_pos_274b98ea9fd940c5_25_parsePrintStatement)
HXLINE(  26)		this->advance();
HXLINE(  27)		 ::src::ast::Expr expr = this->comparison();
HXLINE(  28)		this->consume(::src::TokenType_obj::SEMICOLON_dyn(),HX_("Expected ';' after value.",76,14,f3,01));
HXLINE(  29)		int _hx_tmp = this->previous()->line;
HXDLIN(  29)		return  ::src::ast::PrintStmt_obj::__alloc( HX_CTX ,expr,_hx_tmp,this->previous()->column);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Parser_obj,parsePrintStatement,return )

 ::src::ast::InputStmt Parser_obj::parseInputStatement(){
            	HX_GC_STACKFRAME(&_hx_pos_274b98ea9fd940c5_33_parseInputStatement)
HXLINE(  34)		this->advance();
HXLINE(  35)		 ::src::Token name = this->consume(::src::TokenType_obj::IDENTIFIER_dyn(),HX_("Expected variable after 'input'.",ca,b5,ec,ae));
HXLINE(  36)		this->consume(::src::TokenType_obj::SEMICOLON_dyn(),HX_("Expected ';' after value.",76,14,f3,01));
HXLINE(  37)		return  ::src::ast::InputStmt_obj::__alloc( HX_CTX , ::src::ast::VariableExpr_obj::__alloc( HX_CTX ,( (::String)(name->value) ),name->line,name->column),name->line,name->column);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Parser_obj,parseInputStatement,return )

 ::src::ast::LetStmt Parser_obj::parseLetStatement(){
            	HX_GC_STACKFRAME(&_hx_pos_274b98ea9fd940c5_41_parseLetStatement)
HXLINE(  42)		this->advance();
HXLINE(  43)		::Array< ::Dynamic> bindings = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  44)		do {
HXLINE(  45)			 ::src::Token name = this->consume(::src::TokenType_obj::IDENTIFIER_dyn(),HX_("Expected variable name in let statement.",e6,d3,0f,26));
HXLINE(  46)			bindings->push( ::src::ast::VariableExpr_obj::__alloc( HX_CTX ,( (::String)(name->value) ),name->line,name->column));
            		} while(this->match(::src::TokenType_obj::COMMA_dyn()));
;
HXLINE(  49)		if (this->check(::src::TokenType_obj::EQUALS_dyn())) {
HXLINE(  50)			this->consume(::src::TokenType_obj::EQUALS_dyn(),HX_("Expected '=' after variable names in let statement.",fe,98,69,c3));
HXLINE(  51)			 ::src::ast::Expr value = this->comparison();
HXLINE(  52)			this->consume(::src::TokenType_obj::SEMICOLON_dyn(),HX_("Expected ';' after value.",76,14,f3,01));
HXLINE(  53)			int _hx_tmp = this->previous()->line;
HXDLIN(  53)			return  ::src::ast::LetStmt_obj::__alloc( HX_CTX ,bindings,value,_hx_tmp,this->previous()->column);
            		}
            		else {
HXLINE(  55)			this->consume(::src::TokenType_obj::SEMICOLON_dyn(),HX_("Expected ';' after variable names.",d1,90,75,93));
HXLINE(  56)			int _hx_tmp1 = this->previous()->line;
HXDLIN(  56)			return  ::src::ast::LetStmt_obj::__alloc( HX_CTX ,bindings,null(),_hx_tmp1,this->previous()->column);
            		}
HXLINE(  49)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Parser_obj,parseLetStatement,return )

 ::src::ast::WhileStmt Parser_obj::parseWhileStatement(){
            	HX_GC_STACKFRAME(&_hx_pos_274b98ea9fd940c5_61_parseWhileStatement)
HXLINE(  62)		this->advance();
HXLINE(  63)		 ::src::ast::Expr condition = this->comparison();
HXLINE(  64)		this->consume(::src::TokenType_obj::KEYWORD_dyn(),HX_("Expected 'do' after condition.",3a,7e,1f,f0));
HXLINE(  65)		if ((( (::String)(this->previous()->value) ) != HX_("do",8b,57,00,00))) {
HXLINE(  65)			HX_STACK_DO_THROW(HX_("Expected 'do' after condition.",3a,7e,1f,f0));
            		}
HXLINE(  66)		int body = this->previous()->line;
HXDLIN(  66)		 ::src::ast::BlockStmt body1 = this->parseBlockWithTerminators(::Array_obj< ::String >::fromData( _hx_array_data_0a6f2549_8,1),body,this->previous()->column);
HXLINE(  67)		 ::src::Token kwEnd = this->consume(::src::TokenType_obj::KEYWORD_dyn(),HX_("Expected 'end' after while statement.",27,61,a3,8a));
HXLINE(  68)		if ((( (::String)(kwEnd->value) ) != HX_("end",db,03,4d,00))) {
HXLINE(  68)			HX_STACK_DO_THROW(HX_("Expected 'end' after while statement.",27,61,a3,8a));
            		}
HXLINE(  70)		return  ::src::ast::WhileStmt_obj::__alloc( HX_CTX ,condition,body1,condition->line,condition->column);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Parser_obj,parseWhileStatement,return )

 ::src::ast::IfStmt Parser_obj::parseIfStatement(){
            	HX_GC_STACKFRAME(&_hx_pos_274b98ea9fd940c5_74_parseIfStatement)
HXLINE(  75)		this->advance();
HXLINE(  76)		 ::src::ast::Expr condition = this->comparison();
HXLINE(  77)		this->consume(::src::TokenType_obj::KEYWORD_dyn(),HX_("Expected 'then' after condition.",cc,6b,d7,7f));
HXLINE(  78)		if ((( (::String)(this->previous()->value) ) != HX_("then",dd,02,fc,4c))) {
HXLINE(  78)			HX_STACK_DO_THROW(HX_("Expected 'then' after condition.",cc,6b,d7,7f));
            		}
HXLINE(  79)		int thenBranch = this->previous()->line;
HXDLIN(  79)		 ::src::ast::BlockStmt thenBranch1 = this->parseBlockWithTerminators(::Array_obj< ::String >::fromData( _hx_array_data_0a6f2549_10,2),thenBranch,this->previous()->column);
HXLINE(  80)		 ::src::ast::BlockStmt elseBranch = null();
HXLINE(  81)		bool _hx_tmp;
HXDLIN(  81)		if (this->check(::src::TokenType_obj::KEYWORD_dyn())) {
HXLINE(  81)			_hx_tmp = (( (::String)(this->peek()->value) ) == HX_("else",b9,e4,14,43));
            		}
            		else {
HXLINE(  81)			_hx_tmp = false;
            		}
HXDLIN(  81)		if (_hx_tmp) {
HXLINE(  82)			this->advance();
HXLINE(  83)			int elseBranch1 = this->previous()->line;
HXDLIN(  83)			elseBranch = this->parseBlockWithTerminators(::Array_obj< ::String >::fromData( _hx_array_data_0a6f2549_11,1),elseBranch1,this->previous()->column);
            		}
HXLINE(  86)		 ::src::Token kwEnd = this->consume(::src::TokenType_obj::KEYWORD_dyn(),HX_("Expected 'end' after if statement.",e9,5a,ef,63));
HXLINE(  87)		if ((( (::String)(kwEnd->value) ) != HX_("end",db,03,4d,00))) {
HXLINE(  87)			HX_STACK_DO_THROW(HX_("Expected 'end' after if statement.",e9,5a,ef,63));
            		}
HXLINE(  89)		return  ::src::ast::IfStmt_obj::__alloc( HX_CTX ,condition,thenBranch1,elseBranch,condition->line,condition->column);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Parser_obj,parseIfStatement,return )

 ::src::ast::LetStmt Parser_obj::parseIncStatement(){
            	HX_GC_STACKFRAME(&_hx_pos_274b98ea9fd940c5_93_parseIncStatement)
HXLINE(  94)		this->advance();
HXLINE(  95)		 ::src::Token name = this->consume(::src::TokenType_obj::IDENTIFIER_dyn(),HX_("Expected variable after 'inc'.",5e,33,b9,b7));
HXLINE(  96)		this->consume(::src::TokenType_obj::SEMICOLON_dyn(),HX_("Expected ';' after variable.",39,1f,80,00));
HXLINE(  97)		 ::src::ast::VariableExpr varExpr =  ::src::ast::VariableExpr_obj::__alloc( HX_CTX ,( (::String)(name->value) ),name->line,name->column);
HXLINE(  98)		 ::src::ast::NumberExpr one =  ::src::ast::NumberExpr_obj::__alloc( HX_CTX ,( (Float)(1) ),name->line,name->column);
HXLINE(  99)		 ::src::ast::BinaryExpr binary =  ::src::ast::BinaryExpr_obj::__alloc( HX_CTX ,varExpr, ::src::Token_obj::__alloc( HX_CTX ,::src::TokenType_obj::PLUS_dyn(),HX_("+",2b,00,00,00),name->line,name->column),one,name->line,name->column);
HXLINE( 100)		::String _hx_tmp;
HXDLIN( 100)		if (::hx::IsNull( name->value )) {
HXLINE( 100)			_hx_tmp = HX_("null",87,9e,0e,49);
            		}
            		else {
HXLINE( 100)			_hx_tmp = ::Std_obj::string(name->value);
            		}
HXDLIN( 100)		return  ::src::ast::LetStmt_obj::__alloc( HX_CTX ,::Array_obj< ::Dynamic>::__new(1)->init(0, ::src::ast::VariableExpr_obj::__alloc( HX_CTX ,_hx_tmp,name->line,name->column)),binary,name->line,name->column);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Parser_obj,parseIncStatement,return )

 ::src::ast::LetStmt Parser_obj::parseDecStatement(){
            	HX_GC_STACKFRAME(&_hx_pos_274b98ea9fd940c5_104_parseDecStatement)
HXLINE( 105)		this->advance();
HXLINE( 106)		 ::src::Token name = this->consume(::src::TokenType_obj::IDENTIFIER_dyn(),HX_("Expected variable after 'dec'.",42,61,c5,d0));
HXLINE( 107)		this->consume(::src::TokenType_obj::SEMICOLON_dyn(),HX_("Expected ';' after variable.",39,1f,80,00));
HXLINE( 108)		 ::src::ast::VariableExpr varExpr =  ::src::ast::VariableExpr_obj::__alloc( HX_CTX ,( (::String)(name->value) ),name->line,name->column);
HXLINE( 109)		 ::src::ast::NumberExpr one =  ::src::ast::NumberExpr_obj::__alloc( HX_CTX ,( (Float)(1) ),name->line,name->column);
HXLINE( 110)		 ::src::ast::BinaryExpr binary =  ::src::ast::BinaryExpr_obj::__alloc( HX_CTX ,varExpr, ::src::Token_obj::__alloc( HX_CTX ,::src::TokenType_obj::MINUS_dyn(),HX_("-",2d,00,00,00),name->line,name->column),one,name->line,name->column);
HXLINE( 111)		::String _hx_tmp;
HXDLIN( 111)		if (::hx::IsNull( name->value )) {
HXLINE( 111)			_hx_tmp = HX_("null",87,9e,0e,49);
            		}
            		else {
HXLINE( 111)			_hx_tmp = ::Std_obj::string(name->value);
            		}
HXDLIN( 111)		return  ::src::ast::LetStmt_obj::__alloc( HX_CTX ,::Array_obj< ::Dynamic>::__new(1)->init(0, ::src::ast::VariableExpr_obj::__alloc( HX_CTX ,_hx_tmp,name->line,name->column)),binary,name->line,name->column);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Parser_obj,parseDecStatement,return )

 ::src::ast::BlockStmt Parser_obj::parseBlockWithTerminators(::Array< ::String > terminators,int line,int column){
            	HX_GC_STACKFRAME(&_hx_pos_274b98ea9fd940c5_115_parseBlockWithTerminators)
HXLINE( 116)		::Array< ::Dynamic> statements = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 117)		while(true){
HXLINE( 117)			bool _hx_tmp;
HXDLIN( 117)			if (!(this->isAtEnd())) {
HXLINE( 117)				bool _hx_tmp1;
HXDLIN( 117)				if (this->check(::src::TokenType_obj::KEYWORD_dyn())) {
HXLINE( 117)					_hx_tmp1 = (terminators->indexOf(( (::String)(this->peek()->value) ),null()) != -1);
            				}
            				else {
HXLINE( 117)					_hx_tmp1 = false;
            				}
HXDLIN( 117)				_hx_tmp = !(_hx_tmp1);
            			}
            			else {
HXLINE( 117)				_hx_tmp = false;
            			}
HXDLIN( 117)			if (!(_hx_tmp)) {
HXLINE( 117)				goto _hx_goto_14;
            			}
HXLINE( 118)			statements->push(this->parseStatement());
            		}
            		_hx_goto_14:;
HXLINE( 121)		return  ::src::ast::BlockStmt_obj::__alloc( HX_CTX ,statements,line,column);
            	}


HX_DEFINE_DYNAMIC_FUNC3(Parser_obj,parseBlockWithTerminators,return )

 ::src::ast::Stmt Parser_obj::parseStatement(){
            	HX_GC_STACKFRAME(&_hx_pos_274b98ea9fd940c5_125_parseStatement)
HXLINE( 126)		bool _hx_tmp;
HXDLIN( 126)		if (this->check(::src::TokenType_obj::KEYWORD_dyn())) {
HXLINE( 126)			_hx_tmp = (( (::String)(this->peek()->value) ) == HX_("print",2d,58,8b,c8));
            		}
            		else {
HXLINE( 126)			_hx_tmp = false;
            		}
HXDLIN( 126)		if (_hx_tmp) {
HXLINE( 126)			return this->parsePrintStatement();
            		}
HXLINE( 127)		bool _hx_tmp1;
HXDLIN( 127)		if (this->check(::src::TokenType_obj::KEYWORD_dyn())) {
HXLINE( 127)			_hx_tmp1 = (( (::String)(this->peek()->value) ) == HX_("input",0a,c4,1d,be));
            		}
            		else {
HXLINE( 127)			_hx_tmp1 = false;
            		}
HXDLIN( 127)		if (_hx_tmp1) {
HXLINE( 127)			return this->parseInputStatement();
            		}
HXLINE( 128)		bool _hx_tmp2;
HXDLIN( 128)		if (this->check(::src::TokenType_obj::KEYWORD_dyn())) {
HXLINE( 128)			_hx_tmp2 = (( (::String)(this->peek()->value) ) == HX_("let",db,4b,52,00));
            		}
            		else {
HXLINE( 128)			_hx_tmp2 = false;
            		}
HXDLIN( 128)		if (_hx_tmp2) {
HXLINE( 128)			return this->parseLetStatement();
            		}
HXLINE( 129)		bool _hx_tmp3;
HXDLIN( 129)		if (this->check(::src::TokenType_obj::KEYWORD_dyn())) {
HXLINE( 129)			_hx_tmp3 = (( (::String)(this->peek()->value) ) == HX_("if",dd,5b,00,00));
            		}
            		else {
HXLINE( 129)			_hx_tmp3 = false;
            		}
HXDLIN( 129)		if (_hx_tmp3) {
HXLINE( 129)			return this->parseIfStatement();
            		}
HXLINE( 130)		bool _hx_tmp4;
HXDLIN( 130)		if (this->check(::src::TokenType_obj::KEYWORD_dyn())) {
HXLINE( 130)			_hx_tmp4 = (( (::String)(this->peek()->value) ) == HX_("while",b1,43,bd,c9));
            		}
            		else {
HXLINE( 130)			_hx_tmp4 = false;
            		}
HXDLIN( 130)		if (_hx_tmp4) {
HXLINE( 130)			return this->parseWhileStatement();
            		}
HXLINE( 131)		bool _hx_tmp5;
HXDLIN( 131)		if (this->check(::src::TokenType_obj::KEYWORD_dyn())) {
HXLINE( 131)			_hx_tmp5 = (( (::String)(this->peek()->value) ) == HX_("inc",de,0c,50,00));
            		}
            		else {
HXLINE( 131)			_hx_tmp5 = false;
            		}
HXDLIN( 131)		if (_hx_tmp5) {
HXLINE( 131)			return this->parseIncStatement();
            		}
HXLINE( 132)		bool _hx_tmp6;
HXDLIN( 132)		if (this->check(::src::TokenType_obj::KEYWORD_dyn())) {
HXLINE( 132)			_hx_tmp6 = (( (::String)(this->peek()->value) ) == HX_("dec",c2,39,4c,00));
            		}
            		else {
HXLINE( 132)			_hx_tmp6 = false;
            		}
HXDLIN( 132)		if (_hx_tmp6) {
HXLINE( 132)			return this->parseDecStatement();
            		}
HXLINE( 135)		 ::src::ast::Expr _hx_tmp7 = this->comparison();
HXDLIN( 135)		int _hx_tmp8 = this->peek()->line;
HXDLIN( 135)		return  ::src::ast::ExprStmt_obj::__alloc( HX_CTX ,_hx_tmp7,_hx_tmp8,this->peek()->column);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Parser_obj,parseStatement,return )

 ::src::ast::Expr Parser_obj::comparison(){
            	HX_GC_STACKFRAME(&_hx_pos_274b98ea9fd940c5_138_comparison)
HXLINE( 139)		 ::src::ast::Expr left = this->expr();
HXLINE( 140)		while(true){
HXLINE( 140)			bool _hx_tmp;
HXDLIN( 140)			bool _hx_tmp1;
HXDLIN( 140)			bool _hx_tmp2;
HXDLIN( 140)			bool _hx_tmp3;
HXDLIN( 140)			bool _hx_tmp4;
HXDLIN( 140)			if (!(this->match(::src::TokenType_obj::GT_dyn()))) {
HXLINE( 140)				_hx_tmp4 = this->match(::src::TokenType_obj::GTEQ_dyn());
            			}
            			else {
HXLINE( 140)				_hx_tmp4 = true;
            			}
HXDLIN( 140)			if (!(_hx_tmp4)) {
HXLINE( 140)				_hx_tmp3 = this->match(::src::TokenType_obj::LT_dyn());
            			}
            			else {
HXLINE( 140)				_hx_tmp3 = true;
            			}
HXDLIN( 140)			if (!(_hx_tmp3)) {
HXLINE( 140)				_hx_tmp2 = this->match(::src::TokenType_obj::LTEQ_dyn());
            			}
            			else {
HXLINE( 140)				_hx_tmp2 = true;
            			}
HXDLIN( 140)			if (!(_hx_tmp2)) {
HXLINE( 140)				_hx_tmp1 = this->match(::src::TokenType_obj::EQEQ_dyn());
            			}
            			else {
HXLINE( 140)				_hx_tmp1 = true;
            			}
HXDLIN( 140)			if (!(_hx_tmp1)) {
HXLINE( 140)				_hx_tmp = this->match(::src::TokenType_obj::NOTEQ_dyn());
            			}
            			else {
HXLINE( 140)				_hx_tmp = true;
            			}
HXDLIN( 140)			if (!(_hx_tmp)) {
HXLINE( 140)				goto _hx_goto_17;
            			}
HXLINE( 141)			 ::src::Token oper = this->previous();
HXLINE( 142)			 ::src::ast::Expr right = this->term();
HXLINE( 143)			left =  ::src::ast::BinaryExpr_obj::__alloc( HX_CTX ,left,oper,right,oper->line,oper->column);
            		}
            		_hx_goto_17:;
HXLINE( 145)		return left;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Parser_obj,comparison,return )

 ::src::ast::Expr Parser_obj::expr(){
            	HX_GC_STACKFRAME(&_hx_pos_274b98ea9fd940c5_149_expr)
HXLINE( 150)		 ::src::ast::Expr left = this->term();
HXLINE( 151)		while(true){
HXLINE( 151)			bool _hx_tmp;
HXDLIN( 151)			if (!(this->match(::src::TokenType_obj::PLUS_dyn()))) {
HXLINE( 151)				_hx_tmp = this->match(::src::TokenType_obj::MINUS_dyn());
            			}
            			else {
HXLINE( 151)				_hx_tmp = true;
            			}
HXDLIN( 151)			if (!(_hx_tmp)) {
HXLINE( 151)				goto _hx_goto_19;
            			}
HXLINE( 152)			 ::src::Token oper = this->previous();
HXLINE( 153)			 ::src::ast::Expr right = this->term();
HXLINE( 154)			left =  ::src::ast::BinaryExpr_obj::__alloc( HX_CTX ,left,oper,right,oper->line,oper->column);
            		}
            		_hx_goto_19:;
HXLINE( 156)		return left;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Parser_obj,expr,return )

 ::src::ast::Expr Parser_obj::term(){
            	HX_GC_STACKFRAME(&_hx_pos_274b98ea9fd940c5_160_term)
HXLINE( 161)		 ::src::ast::Expr left = this->unary();
HXLINE( 162)		while(true){
HXLINE( 162)			bool _hx_tmp;
HXDLIN( 162)			if (!(this->match(::src::TokenType_obj::STAR_dyn()))) {
HXLINE( 162)				_hx_tmp = this->match(::src::TokenType_obj::SLASH_dyn());
            			}
            			else {
HXLINE( 162)				_hx_tmp = true;
            			}
HXDLIN( 162)			if (!(_hx_tmp)) {
HXLINE( 162)				goto _hx_goto_21;
            			}
HXLINE( 163)			 ::src::Token oper = this->previous();
HXLINE( 164)			 ::src::ast::Expr right = this->unary();
HXLINE( 165)			left =  ::src::ast::BinaryExpr_obj::__alloc( HX_CTX ,left,oper,right,oper->line,oper->column);
            		}
            		_hx_goto_21:;
HXLINE( 167)		return left;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Parser_obj,term,return )

 ::src::ast::Expr Parser_obj::unary(){
            	HX_GC_STACKFRAME(&_hx_pos_274b98ea9fd940c5_171_unary)
HXLINE( 172)		bool _hx_tmp;
HXDLIN( 172)		if (!(this->check(::src::TokenType_obj::BANG_dyn()))) {
HXLINE( 172)			_hx_tmp = this->check(::src::TokenType_obj::MINUS_dyn());
            		}
            		else {
HXLINE( 172)			_hx_tmp = true;
            		}
HXDLIN( 172)		if (_hx_tmp) {
HXLINE( 173)			 ::src::Token oper = this->advance();
HXLINE( 174)			 ::src::ast::Expr right = this->unary();
HXLINE( 175)			return  ::src::ast::UnaryExpr_obj::__alloc( HX_CTX ,oper,right,oper->line,oper->column);
            		}
HXLINE( 177)		return this->factor();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Parser_obj,unary,return )

 ::src::ast::Expr Parser_obj::factor(){
            	HX_GC_STACKFRAME(&_hx_pos_274b98ea9fd940c5_181_factor)
HXLINE( 182)		if (this->match(::src::TokenType_obj::NUMBER_dyn())) {
HXLINE( 183)			Float _hx_tmp = ::Std_obj::parseFloat(( (::String)(this->previous()->value) ));
HXDLIN( 183)			int _hx_tmp1 = this->previous()->line;
HXDLIN( 183)			return  ::src::ast::NumberExpr_obj::__alloc( HX_CTX ,_hx_tmp,_hx_tmp1,this->previous()->column);
            		}
HXLINE( 185)		if (this->match(::src::TokenType_obj::LPAREN_dyn())) {
HXLINE( 186)			 ::src::ast::Expr expr = this->expr();
HXLINE( 187)			this->consume(::src::TokenType_obj::RPAREN_dyn(),HX_("Expected ')' after expression.",ef,fc,f7,96));
HXLINE( 188)			return expr;
            		}
HXLINE( 190)		if (this->match(::src::TokenType_obj::IDENTIFIER_dyn())) {
HXLINE( 191)			::String _hx_tmp2 = ( (::String)(this->previous()->value) );
HXDLIN( 191)			int _hx_tmp3 = this->previous()->line;
HXDLIN( 191)			return  ::src::ast::VariableExpr_obj::__alloc( HX_CTX ,_hx_tmp2,_hx_tmp3,this->previous()->column);
            		}
HXLINE( 193)		if (this->match(::src::TokenType_obj::STRING_dyn())) {
HXLINE( 194)			::String _hx_tmp4 = ( (::String)(this->previous()->value) );
HXDLIN( 194)			int _hx_tmp5 = this->previous()->line;
HXDLIN( 194)			return  ::src::ast::StringExpr_obj::__alloc( HX_CTX ,_hx_tmp4,_hx_tmp5,this->previous()->column);
            		}
HXLINE( 196)		bool _hx_tmp6;
HXDLIN( 196)		if (this->check(::src::TokenType_obj::KEYWORD_dyn())) {
HXLINE( 196)			if ((( (::String)(this->peek()->value) ) != HX_("true",4e,a7,03,4d))) {
HXLINE( 196)				_hx_tmp6 = (( (::String)(this->peek()->value) ) == HX_("false",a3,35,4f,fb));
            			}
            			else {
HXLINE( 196)				_hx_tmp6 = true;
            			}
            		}
            		else {
HXLINE( 196)			_hx_tmp6 = false;
            		}
HXDLIN( 196)		if (_hx_tmp6) {
HXLINE( 197)			 ::src::Token kw = this->advance();
HXLINE( 198)			return  ::src::ast::BooleanExpr_obj::__alloc( HX_CTX ,(( (::String)(kw->value) ) == HX_("true",4e,a7,03,4d)),kw->line,kw->column);
            		}
HXLINE( 200)		HX_STACK_DO_THROW((HX_("Unexpected token in factor: ",3a,0b,e3,25) + ::Std_obj::string(this->peek())));
HXDLIN( 200)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Parser_obj,factor,return )

bool Parser_obj::match( ::src::TokenType type){
            	HX_STACKFRAME(&_hx_pos_274b98ea9fd940c5_204_match)
HXLINE( 205)		if (this->check(type)) {
HXLINE( 206)			this->advance();
HXLINE( 207)			return true;
            		}
HXLINE( 209)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Parser_obj,match,return )

 ::src::Token Parser_obj::consume( ::src::TokenType type,::String message){
            	HX_STACKFRAME(&_hx_pos_274b98ea9fd940c5_213_consume)
HXLINE( 214)		if (this->check(type)) {
HXLINE( 214)			return this->advance();
            		}
HXLINE( 215)		HX_STACK_DO_THROW(((message + HX_(" -- Found: ",a8,24,01,8b)) + ::Std_obj::string(this->peek())));
HXDLIN( 215)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC2(Parser_obj,consume,return )

bool Parser_obj::check( ::src::TokenType type){
            	HX_STACKFRAME(&_hx_pos_274b98ea9fd940c5_219_check)
HXLINE( 220)		if (this->isAtEnd()) {
HXLINE( 220)			return false;
            		}
HXLINE( 221)		return ::hx::IsPointerEq( this->peek()->type,type );
            	}


HX_DEFINE_DYNAMIC_FUNC1(Parser_obj,check,return )

 ::src::Token Parser_obj::advance(){
            	HX_STACKFRAME(&_hx_pos_274b98ea9fd940c5_225_advance)
HXLINE( 226)		if (!(this->isAtEnd())) {
HXLINE( 226)			this->position++;
            		}
HXLINE( 227)		return this->previous();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Parser_obj,advance,return )

bool Parser_obj::isAtEnd(){
            	HX_STACKFRAME(&_hx_pos_274b98ea9fd940c5_232_isAtEnd)
HXDLIN( 232)		return (this->position >= this->tokens->length);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Parser_obj,isAtEnd,return )

 ::src::Token Parser_obj::peek(){
            	HX_STACKFRAME(&_hx_pos_274b98ea9fd940c5_237_peek)
HXDLIN( 237)		if (this->isAtEnd()) {
HXDLIN( 237)			return null();
            		}
            		else {
HXDLIN( 237)			return this->tokens->__get(this->position).StaticCast<  ::src::Token >();
            		}
HXDLIN( 237)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Parser_obj,peek,return )

 ::src::Token Parser_obj::previous(){
            	HX_STACKFRAME(&_hx_pos_274b98ea9fd940c5_242_previous)
HXDLIN( 242)		if ((this->position > 0)) {
HXDLIN( 242)			return this->tokens->__get((this->position - 1)).StaticCast<  ::src::Token >();
            		}
            		else {
HXDLIN( 242)			return null();
            		}
HXDLIN( 242)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Parser_obj,previous,return )


::hx::ObjectPtr< Parser_obj > Parser_obj::__new(::Array< ::Dynamic> tokens) {
	::hx::ObjectPtr< Parser_obj > __this = new Parser_obj();
	__this->__construct(tokens);
	return __this;
}

::hx::ObjectPtr< Parser_obj > Parser_obj::__alloc(::hx::Ctx *_hx_ctx,::Array< ::Dynamic> tokens) {
	Parser_obj *__this = (Parser_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Parser_obj), true, "src.Parser"));
	*(void **)__this = Parser_obj::_hx_vtable;
	__this->__construct(tokens);
	return __this;
}

Parser_obj::Parser_obj()
{
}

void Parser_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Parser);
	HX_MARK_MEMBER_NAME(tokens,"tokens");
	HX_MARK_MEMBER_NAME(position,"position");
	HX_MARK_END_CLASS();
}

void Parser_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(tokens,"tokens");
	HX_VISIT_MEMBER_NAME(position,"position");
}

::hx::Val Parser_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"expr") ) { return ::hx::Val( expr_dyn() ); }
		if (HX_FIELD_EQ(inName,"term") ) { return ::hx::Val( term_dyn() ); }
		if (HX_FIELD_EQ(inName,"peek") ) { return ::hx::Val( peek_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"parse") ) { return ::hx::Val( parse_dyn() ); }
		if (HX_FIELD_EQ(inName,"unary") ) { return ::hx::Val( unary_dyn() ); }
		if (HX_FIELD_EQ(inName,"match") ) { return ::hx::Val( match_dyn() ); }
		if (HX_FIELD_EQ(inName,"check") ) { return ::hx::Val( check_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"tokens") ) { return ::hx::Val( tokens ); }
		if (HX_FIELD_EQ(inName,"factor") ) { return ::hx::Val( factor_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"consume") ) { return ::hx::Val( consume_dyn() ); }
		if (HX_FIELD_EQ(inName,"advance") ) { return ::hx::Val( advance_dyn() ); }
		if (HX_FIELD_EQ(inName,"isAtEnd") ) { return ::hx::Val( isAtEnd_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"position") ) { return ::hx::Val( position ); }
		if (HX_FIELD_EQ(inName,"previous") ) { return ::hx::Val( previous_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"comparison") ) { return ::hx::Val( comparison_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"parseStatement") ) { return ::hx::Val( parseStatement_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"parseIfStatement") ) { return ::hx::Val( parseIfStatement_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"parseLetStatement") ) { return ::hx::Val( parseLetStatement_dyn() ); }
		if (HX_FIELD_EQ(inName,"parseIncStatement") ) { return ::hx::Val( parseIncStatement_dyn() ); }
		if (HX_FIELD_EQ(inName,"parseDecStatement") ) { return ::hx::Val( parseDecStatement_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"parsePrintStatement") ) { return ::hx::Val( parsePrintStatement_dyn() ); }
		if (HX_FIELD_EQ(inName,"parseInputStatement") ) { return ::hx::Val( parseInputStatement_dyn() ); }
		if (HX_FIELD_EQ(inName,"parseWhileStatement") ) { return ::hx::Val( parseWhileStatement_dyn() ); }
		break;
	case 25:
		if (HX_FIELD_EQ(inName,"parseBlockWithTerminators") ) { return ::hx::Val( parseBlockWithTerminators_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val Parser_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"tokens") ) { tokens=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"position") ) { position=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Parser_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("tokens",5a,17,e7,91));
	outFields->push(HX_("position",a9,a0,fa,ca));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Parser_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Parser_obj,tokens),HX_("tokens",5a,17,e7,91)},
	{::hx::fsInt,(int)offsetof(Parser_obj,position),HX_("position",a9,a0,fa,ca)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Parser_obj_sStaticStorageInfo = 0;
#endif

static ::String Parser_obj_sMemberFields[] = {
	HX_("tokens",5a,17,e7,91),
	HX_("position",a9,a0,fa,ca),
	HX_("parse",33,90,55,bd),
	HX_("parsePrintStatement",d5,29,c3,00),
	HX_("parseInputStatement",58,da,54,e9),
	HX_("parseLetStatement",a7,35,14,75),
	HX_("parseWhileStatement",d1,ad,e1,53),
	HX_("parseIfStatement",1f,17,aa,ce),
	HX_("parseIncStatement",44,bc,b5,72),
	HX_("parseDecStatement",e0,d2,26,a2),
	HX_("parseBlockWithTerminators",8c,b3,38,67),
	HX_("parseStatement",7c,c9,48,84),
	HX_("comparison",49,9b,62,11),
	HX_("expr",35,fd,1d,43),
	HX_("term",6c,c7,f9,4c),
	HX_("unary",af,55,e1,a6),
	HX_("factor",cf,98,0d,e4),
	HX_("match",45,49,23,03),
	HX_("consume",bc,79,da,18),
	HX_("check",c8,98,b6,45),
	HX_("advance",82,08,0c,ef),
	HX_("isAtEnd",5e,64,45,c3),
	HX_("peek",9b,e1,54,4a),
	HX_("previous",37,bc,b0,23),
	::String(null()) };

::hx::Class Parser_obj::__mClass;

void Parser_obj::__register()
{
	Parser_obj _hx_dummy;
	Parser_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("src.Parser",49,25,6f,0a);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Parser_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Parser_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Parser_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Parser_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace src
