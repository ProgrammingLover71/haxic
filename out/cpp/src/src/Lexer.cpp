// Generated by Haxe 4.3.7
#include <hxcpp.h>

#ifndef INCLUDED_EReg
#include <EReg.h>
#endif
#ifndef INCLUDED_src_Lexer
#include <src/Lexer.h>
#endif
#ifndef INCLUDED_src_Token
#include <src/Token.h>
#endif
#ifndef INCLUDED_src_TokenType
#include <src/TokenType.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_3dd68e9c2b948807_3_new,"src.Lexer","new",0xd33346d4,"src.Lexer.new","src/Lexer.hx",3,0xd3e3d81d)
HX_LOCAL_STACK_FRAME(_hx_pos_3dd68e9c2b948807_19_advance,"src.Lexer","advance",0x3059c8f6,"src.Lexer.advance","src/Lexer.hx",19,0xd3e3d81d)
HX_LOCAL_STACK_FRAME(_hx_pos_3dd68e9c2b948807_34_peek,"src.Lexer","peek",0xfafd10a7,"src.Lexer.peek","src/Lexer.hx",34,0xd3e3d81d)
HX_LOCAL_STACK_FRAME(_hx_pos_3dd68e9c2b948807_42_isEof,"src.Lexer","isEof",0xa3cc2a66,"src.Lexer.isEof","src/Lexer.hx",42,0xd3e3d81d)
HX_LOCAL_STACK_FRAME(_hx_pos_3dd68e9c2b948807_46_skipWhitespace,"src.Lexer","skipWhitespace",0x2327c2e8,"src.Lexer.skipWhitespace","src/Lexer.hx",46,0xd3e3d81d)
HX_LOCAL_STACK_FRAME(_hx_pos_3dd68e9c2b948807_51_tokenize,"src.Lexer","tokenize",0x0e129b07,"src.Lexer.tokenize","src/Lexer.hx",51,0xd3e3d81d)
HX_LOCAL_STACK_FRAME(_hx_pos_3dd68e9c2b948807_162_isKeyword,"src.Lexer","isKeyword",0x42918993,"src.Lexer.isKeyword","src/Lexer.hx",162,0xd3e3d81d)
static const ::String _hx_array_data_b9b28ce2_13[] = {
	HX_("print",2d,58,8b,c8),HX_("input",0a,c4,1d,be),HX_("let",db,4b,52,00),HX_("if",dd,5b,00,00),HX_("then",dd,02,fc,4c),HX_("else",b9,e4,14,43),HX_("while",b1,43,bd,c9),HX_("do",8b,57,00,00),HX_("end",db,03,4d,00),HX_("true",4e,a7,03,4d),HX_("false",a3,35,4f,fb),HX_("inc",de,0c,50,00),HX_("dec",c2,39,4c,00),HX_("func",44,eb,c4,43),HX_("return",b0,a4,2d,09),HX_("null",87,9e,0e,49),HX_("for",09,c7,4d,00),HX_("in",e5,5b,00,00),
};
namespace src{

void Lexer_obj::__construct(::String source){
            	HX_STACKFRAME(&_hx_pos_3dd68e9c2b948807_3_new)
HXLINE(   5)		this->position = 0;
HXLINE(  11)		this->source = source;
HXLINE(  12)		this->position = -1;
HXLINE(  13)		this->current = HX_("",00,00,00,00);
HXLINE(  14)		this->line = 1;
HXLINE(  15)		this->column = 0;
HXLINE(  16)		this->advance();
            	}

Dynamic Lexer_obj::__CreateEmpty() { return new Lexer_obj; }

void *Lexer_obj::_hx_vtable = 0;

Dynamic Lexer_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Lexer_obj > _hx_result = new Lexer_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool Lexer_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x295bbf88;
}

void Lexer_obj::advance(){
            	HX_STACKFRAME(&_hx_pos_3dd68e9c2b948807_19_advance)
HXLINE(  20)		this->position++;
HXLINE(  21)		this->column++;
HXLINE(  22)		if ((this->position < this->source.length)) {
HXLINE(  23)			this->current = this->source.charAt(this->position);
HXLINE(  24)			if ((this->current == HX_("\n",0a,00,00,00))) {
HXLINE(  25)				this->line++;
HXLINE(  26)				this->column = 0;
            			}
            		}
            		else {
HXLINE(  29)			this->current = HX_("",00,00,00,00);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Lexer_obj,advance,(void))

::String Lexer_obj::peek(){
            	HX_STACKFRAME(&_hx_pos_3dd68e9c2b948807_34_peek)
HXDLIN(  34)		if ((this->position < this->source.length)) {
HXLINE(  35)			return this->source.charAt(this->position);
            		}
            		else {
HXLINE(  37)			return HX_("",00,00,00,00);
            		}
HXLINE(  34)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Lexer_obj,peek,return )

bool Lexer_obj::isEof(){
            	HX_STACKFRAME(&_hx_pos_3dd68e9c2b948807_42_isEof)
HXDLIN(  42)		return (this->position >= this->source.length);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Lexer_obj,isEof,return )

void Lexer_obj::skipWhitespace(){
            	HX_STACKFRAME(&_hx_pos_3dd68e9c2b948807_46_skipWhitespace)
HXDLIN(  46)		while(true){
HXDLIN(  46)			bool _hx_tmp;
HXDLIN(  46)			if (!(this->isEof())) {
HXDLIN(  46)				bool _hx_tmp1;
HXDLIN(  46)				bool _hx_tmp2;
HXDLIN(  46)				if ((this->current != HX_(" ",20,00,00,00))) {
HXDLIN(  46)					_hx_tmp2 = (this->current == HX_("\t",09,00,00,00));
            				}
            				else {
HXDLIN(  46)					_hx_tmp2 = true;
            				}
HXDLIN(  46)				if (!(_hx_tmp2)) {
HXDLIN(  46)					_hx_tmp1 = (this->current == HX_("\n",0a,00,00,00));
            				}
            				else {
HXDLIN(  46)					_hx_tmp1 = true;
            				}
HXDLIN(  46)				if (!(_hx_tmp1)) {
HXDLIN(  46)					_hx_tmp = (this->current == HX_("\r",0d,00,00,00));
            				}
            				else {
HXDLIN(  46)					_hx_tmp = true;
            				}
            			}
            			else {
HXDLIN(  46)				_hx_tmp = false;
            			}
HXDLIN(  46)			if (!(_hx_tmp)) {
HXDLIN(  46)				goto _hx_goto_4;
            			}
HXLINE(  47)			this->advance();
            		}
            		_hx_goto_4:;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Lexer_obj,skipWhitespace,(void))

::Array< ::Dynamic> Lexer_obj::tokenize(){
            	HX_GC_STACKFRAME(&_hx_pos_3dd68e9c2b948807_51_tokenize)
HXLINE(  52)		::Array< ::Dynamic> tokens = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  55)		while(!(this->isEof())){
HXLINE(  56)			this->skipWhitespace();
HXLINE(  57)			if (this->isEof()) {
HXLINE(  57)				goto _hx_goto_6;
            			}
HXLINE(  59)			::String _hx_switch_0 = this->current;
            			if (  (_hx_switch_0==HX_("!",21,00,00,00)) ){
HXLINE( 114)				if ((this->peek() == HX_("=",3d,00,00,00))) {
HXLINE( 115)					tokens->push( ::src::Token_obj::__alloc( HX_CTX ,::src::TokenType_obj::NOTEQ_dyn(),HX_("!=",fc,1c,00,00),this->line,this->column));
HXLINE( 116)					this->advance();
HXLINE( 117)					this->advance();
            				}
            				else {
HXLINE( 119)					tokens->push( ::src::Token_obj::__alloc( HX_CTX ,::src::TokenType_obj::BANG_dyn(),this->current,this->line,this->column));
HXLINE( 120)					this->advance();
            				}
HXLINE( 114)				goto _hx_goto_9;
            			}
            			if (  (_hx_switch_0==HX_("\"",22,00,00,00)) ){
HXLINE( 127)				int start = (this->position + 1);
HXLINE( 128)				this->advance();
HXLINE( 129)				while(true){
HXLINE( 129)					bool _hx_tmp;
HXDLIN( 129)					if (!(this->isEof())) {
HXLINE( 129)						_hx_tmp = (this->current != HX_("\"",22,00,00,00));
            					}
            					else {
HXLINE( 129)						_hx_tmp = false;
            					}
HXDLIN( 129)					if (!(_hx_tmp)) {
HXLINE( 129)						goto _hx_goto_10;
            					}
HXLINE( 130)					this->advance();
            				}
            				_hx_goto_10:;
HXLINE( 132)				if (this->isEof()) {
HXLINE( 132)					HX_STACK_DO_THROW((((HX_("Unterminated string literal at line ",3b,3a,7f,6b) + this->line) + HX_(", column ",96,fc,25,5b)) + this->column));
            				}
HXLINE( 133)				::String strValue = this->source.substring(start,this->position);
HXLINE( 134)				tokens->push( ::src::Token_obj::__alloc( HX_CTX ,::src::TokenType_obj::STRING_dyn(),strValue,this->line,(this->column - ((this->position - start) + 1))));
HXLINE( 135)				this->advance();
HXLINE( 125)				goto _hx_goto_9;
            			}
            			if (  (_hx_switch_0==HX_("(",28,00,00,00)) ){
HXLINE(  73)				tokens->push( ::src::Token_obj::__alloc( HX_CTX ,::src::TokenType_obj::LPAREN_dyn(),this->current,this->line,this->column));
HXLINE(  74)				this->advance();
HXLINE(  72)				goto _hx_goto_9;
            			}
            			if (  (_hx_switch_0==HX_(")",29,00,00,00)) ){
HXLINE(  76)				tokens->push( ::src::Token_obj::__alloc( HX_CTX ,::src::TokenType_obj::RPAREN_dyn(),this->current,this->line,this->column));
HXLINE(  77)				this->advance();
HXLINE(  75)				goto _hx_goto_9;
            			}
            			if (  (_hx_switch_0==HX_("*",2a,00,00,00)) ){
HXLINE(  67)				tokens->push( ::src::Token_obj::__alloc( HX_CTX ,::src::TokenType_obj::STAR_dyn(),this->current,this->line,this->column));
HXLINE(  68)				this->advance();
HXLINE(  66)				goto _hx_goto_9;
            			}
            			if (  (_hx_switch_0==HX_("+",2b,00,00,00)) ){
HXLINE(  61)				tokens->push( ::src::Token_obj::__alloc( HX_CTX ,::src::TokenType_obj::PLUS_dyn(),this->current,this->line,this->column));
HXLINE(  62)				this->advance();
HXLINE(  60)				goto _hx_goto_9;
            			}
            			if (  (_hx_switch_0==HX_(",",2c,00,00,00)) ){
HXLINE( 123)				tokens->push( ::src::Token_obj::__alloc( HX_CTX ,::src::TokenType_obj::COMMA_dyn(),this->current,this->line,this->column));
HXLINE( 124)				this->advance();
HXLINE( 122)				goto _hx_goto_9;
            			}
            			if (  (_hx_switch_0==HX_("-",2d,00,00,00)) ){
HXLINE(  64)				tokens->push( ::src::Token_obj::__alloc( HX_CTX ,::src::TokenType_obj::MINUS_dyn(),this->current,this->line,this->column));
HXLINE(  65)				this->advance();
HXLINE(  63)				goto _hx_goto_9;
            			}
            			if (  (_hx_switch_0==HX_("/",2f,00,00,00)) ){
HXLINE(  70)				tokens->push( ::src::Token_obj::__alloc( HX_CTX ,::src::TokenType_obj::SLASH_dyn(),this->current,this->line,this->column));
HXLINE(  71)				this->advance();
HXLINE(  69)				goto _hx_goto_9;
            			}
            			if (  (_hx_switch_0==HX_(";",3b,00,00,00)) ){
HXLINE(  85)				tokens->push( ::src::Token_obj::__alloc( HX_CTX ,::src::TokenType_obj::SEMICOLON_dyn(),this->current,this->line,this->column));
HXLINE(  86)				this->advance();
HXLINE(  84)				goto _hx_goto_9;
            			}
            			if (  (_hx_switch_0==HX_("<",3c,00,00,00)) ){
HXLINE( 105)				if ((this->peek() == HX_("=",3d,00,00,00))) {
HXLINE( 106)					tokens->push( ::src::Token_obj::__alloc( HX_CTX ,::src::TokenType_obj::LTEQ_dyn(),HX_("<=",81,34,00,00),this->line,this->column));
HXLINE( 107)					this->advance();
HXLINE( 108)					this->advance();
            				}
            				else {
HXLINE( 110)					tokens->push( ::src::Token_obj::__alloc( HX_CTX ,::src::TokenType_obj::LT_dyn(),this->current,this->line,this->column));
HXLINE( 111)					this->advance();
            				}
HXLINE( 105)				goto _hx_goto_9;
            			}
            			if (  (_hx_switch_0==HX_("=",3d,00,00,00)) ){
HXLINE(  88)				this->advance();
HXLINE(  89)				if ((this->peek() == HX_("=",3d,00,00,00))) {
HXLINE(  90)					tokens->push( ::src::Token_obj::__alloc( HX_CTX ,::src::TokenType_obj::EQEQ_dyn(),HX_("==",60,35,00,00),this->line,this->column));
HXLINE(  91)					this->advance();
            				}
            				else {
HXLINE(  93)					tokens->push( ::src::Token_obj::__alloc( HX_CTX ,::src::TokenType_obj::EQUALS_dyn(),this->current,this->line,this->column));
            				}
HXLINE(  87)				goto _hx_goto_9;
            			}
            			if (  (_hx_switch_0==HX_(">",3e,00,00,00)) ){
HXLINE(  96)				if ((this->peek() == HX_("=",3d,00,00,00))) {
HXLINE(  97)					tokens->push( ::src::Token_obj::__alloc( HX_CTX ,::src::TokenType_obj::GTEQ_dyn(),HX_(">=",3f,36,00,00),this->line,this->column));
HXLINE(  98)					this->advance();
HXLINE(  99)					this->advance();
            				}
            				else {
HXLINE( 101)					tokens->push( ::src::Token_obj::__alloc( HX_CTX ,::src::TokenType_obj::GT_dyn(),this->current,this->line,this->column));
HXLINE( 102)					this->advance();
            				}
HXLINE(  96)				goto _hx_goto_9;
            			}
            			if (  (_hx_switch_0==HX_("[",5b,00,00,00)) ){
HXLINE(  79)				tokens->push( ::src::Token_obj::__alloc( HX_CTX ,::src::TokenType_obj::LBRACK_dyn(),this->current,this->line,this->column));
HXLINE(  80)				this->advance();
HXLINE(  78)				goto _hx_goto_9;
            			}
            			if (  (_hx_switch_0==HX_("]",5d,00,00,00)) ){
HXLINE(  82)				tokens->push( ::src::Token_obj::__alloc( HX_CTX ,::src::TokenType_obj::RBRACK_dyn(),this->current,this->line,this->column));
HXLINE(  83)				this->advance();
HXLINE(  81)				goto _hx_goto_9;
            			}
            			/* default */{
HXLINE( 138)				if ( ::EReg_obj::__alloc( HX_CTX ,HX_("[a-zA-Z_$$]",79,b2,ba,9f),HX_("",00,00,00,00))->match(this->current)) {
HXLINE( 139)					int start1 = this->position;
HXLINE( 140)					while(true){
HXLINE( 140)						bool _hx_tmp1;
HXDLIN( 140)						if (!(this->isEof())) {
HXLINE( 140)							_hx_tmp1 =  ::EReg_obj::__alloc( HX_CTX ,HX_("[a-zA-Z0-9_$$]",bf,dd,18,78),HX_("",00,00,00,00))->match(this->current);
            						}
            						else {
HXLINE( 140)							_hx_tmp1 = false;
            						}
HXDLIN( 140)						if (!(_hx_tmp1)) {
HXLINE( 140)							goto _hx_goto_7;
            						}
HXLINE( 141)						this->advance();
            					}
            					_hx_goto_7:;
HXLINE( 143)					::String identifier = this->source.substring(start1,this->position);
HXLINE( 144)					 ::src::TokenType type;
HXDLIN( 144)					if (this->isKeyword(identifier)) {
HXLINE( 144)						type = ::src::TokenType_obj::KEYWORD_dyn();
            					}
            					else {
HXLINE( 144)						type = ::src::TokenType_obj::IDENTIFIER_dyn();
            					}
HXLINE( 145)					tokens->push( ::src::Token_obj::__alloc( HX_CTX ,type,identifier,this->line,this->column));
            				}
            				else {
HXLINE( 146)					if ( ::EReg_obj::__alloc( HX_CTX ,HX_("[0-9]",1c,5f,53,85),HX_("",00,00,00,00))->match(this->current)) {
HXLINE( 147)						int start2 = this->position;
HXLINE( 148)						while(true){
HXLINE( 148)							bool _hx_tmp2;
HXDLIN( 148)							if (!(this->isEof())) {
HXLINE( 148)								_hx_tmp2 =  ::EReg_obj::__alloc( HX_CTX ,HX_("[0-9]",1c,5f,53,85),HX_("",00,00,00,00))->match(this->current);
            							}
            							else {
HXLINE( 148)								_hx_tmp2 = false;
            							}
HXDLIN( 148)							if (!(_hx_tmp2)) {
HXLINE( 148)								goto _hx_goto_8;
            							}
HXLINE( 149)							this->advance();
            						}
            						_hx_goto_8:;
HXLINE( 151)						::String numberStr = this->source.substring(start2,this->position);
HXLINE( 152)						tokens->push( ::src::Token_obj::__alloc( HX_CTX ,::src::TokenType_obj::NUMBER_dyn(),numberStr,this->line,(this->column - (this->position - start2))));
            					}
            					else {
HXLINE( 155)						HX_STACK_DO_THROW((((((HX_("Unknown character: ",d9,80,f1,ed) + this->current) + HX_(" at line ",df,96,71,22)) + this->line) + HX_(", column ",96,fc,25,5b)) + this->column));
            					}
            				}
            			}
            			_hx_goto_9:;
            		}
            		_hx_goto_6:;
HXLINE( 159)		return tokens;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Lexer_obj,tokenize,return )

bool Lexer_obj::isKeyword(::String identifier){
            	HX_STACKFRAME(&_hx_pos_3dd68e9c2b948807_162_isKeyword)
HXLINE( 163)		::Array< ::String > keywords = ::Array_obj< ::String >::fromData( _hx_array_data_b9b28ce2_13,18);
HXLINE( 164)		return (keywords->indexOf(identifier.toLowerCase(),null()) != -1);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Lexer_obj,isKeyword,return )


::hx::ObjectPtr< Lexer_obj > Lexer_obj::__new(::String source) {
	::hx::ObjectPtr< Lexer_obj > __this = new Lexer_obj();
	__this->__construct(source);
	return __this;
}

::hx::ObjectPtr< Lexer_obj > Lexer_obj::__alloc(::hx::Ctx *_hx_ctx,::String source) {
	Lexer_obj *__this = (Lexer_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Lexer_obj), true, "src.Lexer"));
	*(void **)__this = Lexer_obj::_hx_vtable;
	__this->__construct(source);
	return __this;
}

Lexer_obj::Lexer_obj()
{
}

void Lexer_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Lexer);
	HX_MARK_MEMBER_NAME(source,"source");
	HX_MARK_MEMBER_NAME(position,"position");
	HX_MARK_MEMBER_NAME(current,"current");
	HX_MARK_MEMBER_NAME(line,"line");
	HX_MARK_MEMBER_NAME(column,"column");
	HX_MARK_END_CLASS();
}

void Lexer_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(source,"source");
	HX_VISIT_MEMBER_NAME(position,"position");
	HX_VISIT_MEMBER_NAME(current,"current");
	HX_VISIT_MEMBER_NAME(line,"line");
	HX_VISIT_MEMBER_NAME(column,"column");
}

::hx::Val Lexer_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"line") ) { return ::hx::Val( line ); }
		if (HX_FIELD_EQ(inName,"peek") ) { return ::hx::Val( peek_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"isEof") ) { return ::hx::Val( isEof_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"source") ) { return ::hx::Val( source ); }
		if (HX_FIELD_EQ(inName,"column") ) { return ::hx::Val( column ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"current") ) { return ::hx::Val( current ); }
		if (HX_FIELD_EQ(inName,"advance") ) { return ::hx::Val( advance_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"position") ) { return ::hx::Val( position ); }
		if (HX_FIELD_EQ(inName,"tokenize") ) { return ::hx::Val( tokenize_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"isKeyword") ) { return ::hx::Val( isKeyword_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"skipWhitespace") ) { return ::hx::Val( skipWhitespace_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val Lexer_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"line") ) { line=inValue.Cast< int >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"source") ) { source=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"column") ) { column=inValue.Cast< int >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"current") ) { current=inValue.Cast< ::String >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"position") ) { position=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Lexer_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("source",db,b0,31,32));
	outFields->push(HX_("position",a9,a0,fa,ca));
	outFields->push(HX_("current",39,9c,e3,cb));
	outFields->push(HX_("line",f4,17,b3,47));
	outFields->push(HX_("column",d6,4e,8b,c6));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Lexer_obj_sMemberStorageInfo[] = {
	{::hx::fsString,(int)offsetof(Lexer_obj,source),HX_("source",db,b0,31,32)},
	{::hx::fsInt,(int)offsetof(Lexer_obj,position),HX_("position",a9,a0,fa,ca)},
	{::hx::fsString,(int)offsetof(Lexer_obj,current),HX_("current",39,9c,e3,cb)},
	{::hx::fsInt,(int)offsetof(Lexer_obj,line),HX_("line",f4,17,b3,47)},
	{::hx::fsInt,(int)offsetof(Lexer_obj,column),HX_("column",d6,4e,8b,c6)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Lexer_obj_sStaticStorageInfo = 0;
#endif

static ::String Lexer_obj_sMemberFields[] = {
	HX_("source",db,b0,31,32),
	HX_("position",a9,a0,fa,ca),
	HX_("current",39,9c,e3,cb),
	HX_("line",f4,17,b3,47),
	HX_("column",d6,4e,8b,c6),
	HX_("advance",82,08,0c,ef),
	HX_("peek",9b,e1,54,4a),
	HX_("isEof",f2,2e,4b,c1),
	HX_("skipWhitespace",dc,cc,61,30),
	HX_("tokenize",fb,f5,57,2b),
	HX_("isKeyword",1f,c4,fb,c1),
	::String(null()) };

::hx::Class Lexer_obj::__mClass;

void Lexer_obj::__register()
{
	Lexer_obj _hx_dummy;
	Lexer_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("src.Lexer",e2,8c,b2,b9);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Lexer_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Lexer_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Lexer_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Lexer_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace src
